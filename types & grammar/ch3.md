# Вы не знаете JS: Типы и Синтаксис
# Глава 3: Семейства

Несколько раз в первой и второй главах мы обращались к некоторым встроенным механизмам, вроде `String` и `Number` обычно называемыми «семейства». Давайте теперь разберём их более детально.

Вот список наиболее часто используемых семейств:

* `String()`
* `Number()`
* `Boolean()`
* `Array()`
* `Object()`
* `Function()`
* `RegExp()`
* `Date()`
* `Error()`
* `Symbol()` -- добавлено в ES6!

Как можно заметить эти семейства, по сути, являются встроенными функциями.

Если подходить к JS уже владея языком, вроде Java, JS функция `String()`  напоминает конструктор `String(..)`, используемый в Java для создания строковых значений. Что ж, давайте сразу убедимся, что мы можем делать приёмы вроде:

```js
var s = new String( "Hello World!" );

console.log( s.toString() ); // "Hello World!"
```

Да, *действительно* каждое из этих семейств может быть использовано как конструктор. Однако, то что получится, окажется не совсем тем,  что мы ожидаем.

```js
var a = new String( "abc" );

typeof a; // "object" ... но не "String"

a instanceof String; // true

Object.prototype.toString.call( a ); // "[object String]"
```

Результатом значения, созданного конструктором формы (`new String(“abc”)`) станет объект-обёртка, содержащий примитивное значение `(“abc”)`.

Важно, что `typeof` указывает, что эти объекты, не собственных специальных *типов*, а скорее подтипы типа `object`.

Этот объект-обёртка впоследствии может быть проверен с помощью:

```js
console.log( a );
```

Результат этого выражения разнится, в зависимости от используемого браузера, потому что разработчики консолей свободны в выборе, каким наиболее подходящим способом сериализовать объект для инспекции программистом.

**Внимание:** В момент написания, Chrome  последней версии выдавал что-то вроде `String {0: “a”, 1: “b”, 2: “c”, length: 3 [[PrimitiveValue]]: “abc”}`. А, более ранние версии выдавали `String {0: “a”, 1: “b”, 2: “c”}`. Последний Firefox печатает `String ["a","b","c"]`, но ранее выдавал надпись *“abc”* курсивом с возможностью клика по ней, что открывало объект для инспекции. Понятно, что  результаты выдачи могут довольно быстро подвергаться изменениям, и отображения в  консоли могут отличаться.

Главное здесь, это то, что выражение `new String("abc")` создаёт объект обёртку, внутри которого находится `”abc”`, а не просто примитивное значение `”abc”`.

## Внутренний `[[Class]]`

Такие значения как `typeof` `”object”` (как, к примеру массивы) дополнительно получают свойство `[[Class]]` (правильнее относиться к этому как к внутренней *класс*ификации, а не отношению к классам, как в традиционных классо-ориентированных программах). Это свойство не может быть получено непосредственно, но существует возможность вызвать его косвенно, одолжив встроенный метод `Object.prototype.toString(..)`, вызвав его с соответствующим значением. Например:

```js
Object.prototype.toString.call( [1,2,3] );			// "[object Array]"

Object.prototype.toString.call( /regex-literal/i );	// "[object RegExp]"
```

Итак, для массива в этом примере значение внутреннего `[[Class]]` это `”Array”`, а для регулярного выражения это `”RegExp”`. В большинстве случаев, значение этого внутреннего `[[Class]]` соответствует встроенному конструктору семейства (см. ниже), к которому относится значение, хотя бывают исключения.

Как насчёт примитивных значений? Во-первых `null` и `undefined`:

```js
Object.prototype.toString.call( null );			// "[object Null]"
Object.prototype.toString.call( undefined );	// "[object Undefined]"
```

Следует обратить внимание, что не бывает семейств конструкторов `Null()` и `Undefined()`, тем не менее, нам открываются внутренние значения `[[Class]]` `”Null”` и `”Undefined”`.

Но, для других значений примитивов вроде `string`, `number`, и `boolean`, определено другое поведение, обычно называемое «упаковка» (см. след. параграф «Обёртки Упаковщики»):

```js
Object.prototype.toString.call( "abc" );	// "[object String]"
Object.prototype.toString.call( 42 );		// "[object Number]"
Object.prototype.toString.call( true );		// "[object Boolean]"
```

В этом фрагменте, каждый из простых примитивов автоматически упаковывается в соответствующий объект-обёртку, поэтому `”String”`, `”Number”` и `”Boolean”` открываются нам в виде значения внутреннего свойства `[[Class]]`.

**Внимание:** Поведение `toString()` и `[[Class]]` в ES5 и ES6 немного отличается, детально мы обсудим это в заглавии *ES6 и далее* этой серии.

## Обёртки Упаковки 

Эти объекты обёртки играют очень важную роль. Примитивные значения не имеют свойств или методов, поэтому чтобы вызвать `.length` или `toString()`, нам необходим объект обёртка вокруг значения. Замечательно, что JS автоматически *упаковывает* (оборачивает) примитив для доступа к этим свойствам.

```js
var a = "abc";

a.length; // 3
a.toUpperCase(); // "ABC"
```

Поэтому, если мы собираемся постоянно использовать эти свойства/методы в своих строковых значениях, вроде `i  <  a.length` в циклах `for` к примеру, выглядит убедительным с самого начала иметь значение в форме объекта, чтобы движку JS не было необходимости создавать его для нас.

Но, похоже, это не слишком хорошая идея. Браузеры уже давно оптимизированы на выполнение тривиальных задач типа`.length`, и значит наша программа станет  *по сути медленнее*, если мы попытаемся «переоптимизировать» её напрямую используя объектную форму(что не есть оптимизированный подход).

В основном, обычно нет резона напрямую использовать объектную форму. Проще позволить примитиву «упаковаться» самостоятельно, когда это будет необходимо. Другими словами, никогда не программируйте `new String(“abc”)`, `new Number(42), и т.д.  предпочитая этому литеральные значения примитивов `“abc”` и `42`.

### Изъяны Объектов-Обёрток 

Существует несколько подводных камней при непосредственном использовании объектов-обёрток, о которых вы должны знать, если вы *всё-же* вознамеритесь их использовать.

Рассмотрим, например значение обёртки `Boolean`:

```js
var a = new Boolean( false );

if (!a) {
	console.log( "Oops" ); // never runs
}
```

Проблема в том, что мы создали объект-обёртку для значения `false`, но сами объекты «правдивы» (см. главу 4), поэтому объект ведёт себя иначе по сравнению с его имеющимся `false` значением, что абсолютно противоположно ожиданиям.

Если мы хотим вручную упаковать значение примитива, мы можем использовать функцию `Object(..)` (без использования ключевого слова `new`):

```js
var a = "abc";
var b = new String( a );
var c = Object( a );

typeof a; // "string"
typeof b; // "object"
typeof c; // "object"

b instanceof String; // true
c instanceof String; // true

Object.prototype.toString.call( b ); // "[object String]"
Object.prototype.toString.call( c ); // "[object String]"
```

Повторюсь, обычно не советуют напрямую использовать объекты-обёртки (как `b` и `c` в примере выше), только в редких случаях их использование может оказаться кстати.

## Распаковка 

Если у нас объект-обёртка и мы хотим получить значение имеющегося примитива мы можем использовать метод `valueOf()`:

```js
var a = new String( "abc" );
var b = new Number( 42 );
var c = new Boolean( true );

a.valueOf(); // "abc"
b.valueOf(); // 42
c.valueOf(); // true
```

Распаковка также происходит опосредованно, когда значение объекта-обёртки используется там, где предполагается значение примитива. Этот процесс (приведение/преобразование) будет рассмотрен детально в главе 4, но на беглый взгляд:

```js
var a = new String( "abc" );
var b = a + ""; // `b` has the unboxed primitive value "abc"

typeof a; // "object"
typeof b; // "string"
```

## Семейства как Конструкторы

Для `array`, `object`, `function`, и значений регулярных выражений, практически всегда предпочтительно использование литеральной формы для создания значений, но литеральная форма создаёт тот же вид объекта, что и форма конструктора (имеется ввиду, что “необёрнутого” значения не существует).

Как мы только что видели с другими семействами, форм конструктора, по возможности, следует избегать, если нам только не обойтись без их использования, в основном из-за того, что в них  присутствуют исключения и изъяны, с которыми, по всей вероятности, нам *не хочется* иметь дела.

### `Array(..)`

```js
var a = new Array( 1, 2, 3 );
a; // [1, 2, 3]

var b = [1, 2, 3];
b; // [1, 2, 3]
```

**Внимание:** Конструктор `Array(..)` не требует перед собой ключевого слова `new`. Если мы опустим его, он поведёт себя так, будто оно там присутствует. Поэтому `Array(1,2,3)`, это тоже самое, что `new Array (1,2,3)`.

Конструктор `Array(..)` имеет следующую особенность, если задан только один аргумент `number`, то вместо того, чтобы использовать его значение как *контент* массива, он использует его как длину «задать размер массива» (well sorta).

Это прескверная идея. Прежде всего, потому что можно случайно задать такую форму, попросту забыв об её существовании.

Но, самое странное, что это не возможность «задать размер массива». Вместо этого мы создадим вообще пустой массив, но обозначим его свойство `length`, заданным цифрой значением.

Массив, который не имеет заданных значений в своих ячейках, но имеет свойство `length`, которое *подразумевает* наличие ячеек, это причудливая экзотика  структуры данных в JS, с очень странным и запутанным поведением. Способность создать такое значение осталась исключительно от устаревшей непризнанной функциональности (`”объектов подобных массивам”` вроде объекта `arguments`).

**Внимание:** Массив, имеющий как минимум одну «пустую ячейку» обычно называется «разрежённый массив».

Также не помогает, а только порождает ещё большую путаницу то, как в консоли разработчиков в браузерах по-разному представляется этот пример.

К примеру:

```js
var a = new Array( 3 );

a.length; // 3
a;
```

Сериализация переменной `a` в Chrome на момент написания книги следующая: `[undefined x 3]`.  **Это реально ужасно.** Здесь как-бы подразумевается: «В ячейках массива присутствует три значения `undefined`, и в то же время никаких ячеек нет (так что, название «пустые ячейки» тоже не подходит!)».

Чтобы увидеть разницу, попробуем следующее:

```js
var a = new Array( 3 );
var b = [ undefined, undefined, undefined ];
var c = [];
c.length = 3;

a;
b;
c;
```

**Внимание:** Как видно в примере с `c`, пустые ячейки в массиве, могут получится после его создания. Изменяя `length` массива чтобы  переопределить значение фактически определёных ячеек мы неявно устанавливаем пустые ячейки. По сути мы даже можем вызвать `delete b[1]`, в последнем примере, и эта команда создаст пустую ячейку  в середине массива `b`.

Для `b` (сейчас в Chrome) мы найдём сериализацию `[undefined, undefined, undefined]`, не так как `[undefined x 3]`  для `a` и `c`. Запутались? Что ж, не вы одни.

Ещё хуже, на время написания Firefox для `a` и `c` рапортовал `[ , , , ]`. Ничего не сбивает с толку? Приглядись внимательней. Три запятых означают четыре ячейки, а не три как мы, вообще-то ожидаем.

**Что?!** Firefox добавляет ещё одну  `,` в конец своей сериализации, потому что в ES5 конечные запятые в списках (значения массивов, списки свойств, и т.д.) разрешены (как отброшенные и проигнорированные). Поэтому, если в своей программе или в консоли вы прописали в `a` значение `[ , , , ]`, в действительности вы получите  имеющееся значение вроде `[ , , ]` (что есть массив с тремя пустыми ячейками). Такое предложение, пока  при чтении в консоли разработчика путаница, защитимся выбрав более аккуратную операцию копирования-вставки…

Ты сейчас почесал затылок и повертел глазами от только что прочтённого? Ты не один, расслабься).

К несчастью, всё ещё хуже. Более запутанный, чем в предыдущем примере вывод в консоли `a` и `b` ведёт себя одинаково в одних случаях, и **совсем по-разному в других**:

```js
a.join( "-" ); // "--"
b.join( "-" ); // "--"

a.map(function(v,i){ return i; }); // [ undefined x 3 ]
b.map(function(v,i){ return i; }); // [ 0, 1, 2 ]
```

**Ах.**

Вызов `a.map(..)` не *срабатывает*, потому что ячейки, по сути не существуют, так что `map(..)` нечего итерировать. `join(..)` работает по-другому. В принципе, мы можем размышлять о такой реализованной сортировки примерно так:

```js
function fakeJoin(arr,connector) {
	var str = "";
	for (var i = 0; i < arr.length; i++) {
		if (i > 0) {
			str += connector;
		}
		if (arr[i] !== undefined) {
			str += arr[i];
		}
	}
	return str;
}

var a = new Array( 3 );
fakeJoin( a, "-" ); // "--"
```

Как видно, `join(..)` действует *предполагая* наличие ячеек и делает цикл по значению `.length`. Что бы ни делал `map(..)`, он (по-видимому) обходится без предположений, поэтому результат от странностей «пустых ячеек» неожидан, и, скорее всего, становится причиной отказа выполнения.

Итак, если ты ищешь *не иначе* как создать массив с именно `undefined` значениями (но не с «пустыми ячейками»), как бы ты мог поступить (если не вручную)?

```js
var a = Array.apply( null, { length: 3 } );
a; // [ undefined, undefined, undefined ]
```

Снова запутался? Ну, да, где-то так это работает.

`apply(..)` это утилита, доступная всем функциям, вызывающим используемые функции особым образом.

Первый аргумент это `this` для связываемого объекта (мы обсуждали это в *this и Прототипы Объектов* этой серии), о котором мы здесь не заботимся поэтому задаём объект `null`. Второй аргумент, предположительно должен быть массивом (или чем-то *вроде* массива, например  «объект подобный массиву»). Содержимое этого «массива» «передаётся» как аргумент для вызываемой функции.

Так, `Array.apply(..)` вызывает функцию `Array(..)` и передаёт значение (значение объекта `{length: 3}`), как его аргумент.

Внутри `apply(..)`мы можем представить какой-нибудь цикл `for` (по аналогии с `join()` чуть ранее), который начинается с нуля `0` и продолжается до (но не включая) `length` (`3` в нашем случае).

Для каждого индекса цикл извлекает ключ из объекта. Так, если бы внутри функции `apply(..)` параметром был передан массив-объект `arr`, обращение к свойству получилось бы `arr[0]`, `arr[1]`, и `arr[2]`. Само собой, нет таких свойств в значениях объекта`{ length: 3}` поэтому все три обращения к свойствам вернут `undefined`.

Другими словами вызов функции `Array(..)`, заканчивается, по существу, так `Array(undefined,undefined,undefined)`, результатом чего будет массив заполненный тремя значениями `undefined`, но не теми (беcсмысленными) «пустыми ячейками».

И, хотя `Array.apply(null, {length: 3})` это странный и многословный способ получить массив со значениями `undefined`, он **значительно** лучше и надёжнее чем «пустые ячейки», полученные в ходе самострела `Array(3)`.

Подведём итоги: **никогда, нигде, ни при каких обстоятельствах** вам не следует намеренно создавать и использовать столь экзотические массивы пустых ячеек. Просто не делайте этого. Наломаете дров.

### `Object(..)`, `Function(..)`, и `RegExp(..)`

Применение конструкторов `Object(..)`/`Function(..)`/`Regexp(..)`, тоже не являются обязательным (и тоже не должны использоваться в обычной практике):

```js
var c = new Object();
c.foo = "bar";
c; // { foo: "bar" }

var d = { foo: "bar" };
d; // { foo: "bar" }

var e = new Function( "a", "return a * 2;" );
var f = function(a) { return a * 2; };
function g(a) { return a * 2; }

var h = new RegExp( "^a*b+", "g" );
var i = /^a*b+/g;
```

Практически не видно причин даже использовать конструкторскую форму `new Object()`, из-за того, что она принуждает нас добавлять свойства по одному, а не сразу сколько нужно, как это происходит при создании объекта в форме литерала.

Конструктор `Function` бывает полезен в очень редких случаях, когда необходимо динамически определить параметры функции и/или её тело. **Только не стоит думать о `Function(..)` как о альтернативной форме `eval(..)`.** Динамически определять функцию таким способом практически никогда не придётся. 

Регулярные выражения определяемые в форме литерала (`/^a*b+/g`) явно предпочтительней, не только из-за облегчённого синтаксиса, но и по причине прозводительности – движок JS компилирует и сохраняет их перед выполнением кода. Но, в отличие от других конструкторских форм мы уже знаем, что в `RegExp(..)`имеются некоторые применимые утилиты, в частности возможность динамически определить шаблон регулярного выражения.

```js
var name = "Kyle";
var namePattern = new RegExp( "\\b(?:" + name + ")+\\b", "ig" );

var matches = someText.match( namePattern );
```

Такой сценарий, время от времени, вполне оправдан в программах JS, так что использование `RegExp(“pattern”, “flags”)`, бывает необходимым. 

### `Date(..)` и `Error(..)`

Встроенные конструкторы `Date(..)` и `Error(..)` используются много чаще других семейств, потому что не имеют собственной формы литерала.

Чтобы получить значение объекта даты мы должны использовать `new Date()`. Конструктор `Date(..)` допускает необязательные аргументы для персонализации возвращаемых даты/времени, но если аргументы не указаны, конструктор возвратит текущее время/дату.

Издавна самый применяемый способ конструкции объекта даты это получение метки времени (целое число в миллисекундах, прошедших с начала отсчёта 01 января 1970 года). Мы можем получить её, вызвав `getTime()` в экземпляре объекта даты.

Есть даже более лёгкий подход, обыкновенным вызовом статитческой вспомогательной функции определённой в ES5: `Date.now()`. Полифилл для окружения, предшествовавшего ES5 также изящен и прост:

```js
if (!Date.now) {
	Date.now = function(){
		return (new Date()).getTime();
	};
}
```

**Внимание:** Если мы вызовем `Date()` без `new`, он вернёт нам строковое представление даты/времени текущего момента. Точная форма представления в спецификации языка не определена, однако браузеры примерно одинаково возвращают что-то вроде `"Fri Jul 18 2014 00:31:02 GMT-0500 (CDT)"`.

Конструктор `Error(..)` (по аналогии с конструктором `Array(..)` ранее) ведёт себя одинаково как с ключевым словом `new` перед ним так и без него.

Основная причина, по которой мы можем захотеть создать объект ошибки это возможность объекта захватывать текущий стек контекста исполнения в объект (в большинстве движков JS присутствует свойство `.stack` доступное только для чтения). Этот текущий контекст включает в себя функцию вызов-стека и строку где создался объект ошибки, что облегчает отладку этой ошибки.

Мы обычно можем использовать этот объект ошибки посредством оператора `throw`:

```js
function foo(x) {
	if (!x) {
		throw new Error( "x wasn't provided" );
	}
	// ..
}
```

Экземпляры объекта ошибки обычно имеют как минимум свойство `message`, и иногда ещё несколько дополнительных свойств (которые мы должны рассматривать как «только для чтения») вроде `type`. В то же время, чтобы получить понятный формат объекта ошибки, вместо проверки обозначенного свойства `.stack`, обычно лучше вызвать метод `toString()` для объекта ошибки (явным или неявным способом, см главу 4).

**Совет:** Технически, основное семейство `Error(..)` дополнено несколькими другими семействами с «типовыми-специфическими-ошибками»: `EvalError(..)`, `RangeError(..)`, `ReferenceError(..)`, `SyntaxError(..)`, `TypeError(..)`, и `URIError(..)`. Но «вручную» эти специфические семейства практически не применяются. Они автоматически используются  если наша программа действительно получает исключение (как, например, получение ошибки `ReferenceError`при необъявленной переменной).

### `Symbol(..)`

В новом в ES6 было добавлено ещё одно значение примитива, названное “Symbol”. Символы это специальные «уникальные», (но не гарантированно!) значения, которые могут быть использованы как свойства в объекте без опасений относительно конфликта имён. Прежде всего они спроетированы для специально встроенного поведения в конструкции ES6, но мы можем определить свои собственные символы.

Символы могут использоваться как имена свойств, но мы не сможем увидеть или получить доступ к значению свойства, как из нашей программы, так и из консоли разработчика. Например, если мы определим символ в консоли разработчика, то отобразится что-то вроде `Symbol(Symbol.create)`.

Несколько предопределённых символов в ES6 доступны как статические свойства объекта функции `Symbol`, как-то `Symbol.create`, `Symbol.iterator` и др. Для их использования сделаем что-то вроде:

```js
obj[Symbol.iterator] = function(){ /*..*/ };
```

Чтобы определить собственный символ, надо использовать семейство`Symbol(..)`. Семейство «конструктора» `Symbol(..)` уникально тем, что мы не можем использовать с ним `new`, так как это приведёт к ошибке. 

```js
var mysym = Symbol( "my own symbol" );
mysym;				// Symbol(my own symbol)
mysym.toString();	// "Symbol(my own symbol)"
typeof mysym; 		// "symbol"

var a = { };
a[mysym] = "foobar";

Object.getOwnPropertySymbols( a );
// [ Symbol(my own symbol) ]
```

Хотя символы не являются частными (`Object.getOwnPropertySymbols(..)` отображается объектом, и выражается в публичной форме), их использование в частных или специальных свойствах - основной способ их применения. Большинство разработчиков используют нижнее подчёркивание в префиксе имени, что практически является сигналом соглашения, вроде: «Эй, ты что не видишь, это свойство «частное/специальное/для внутреннего использования», оставь его в покое»!

**Внимание:** `Symblos`s это *не* `object`s, но обычные скалярные примитивы.

### Прототипы Семейств 

Каждый из встроенных конструкторов семейств  имеет свои собственные `.prototype` объекты. `Array.prototype`, `String.prototype`, и др.

В эти объектах содержится уникальное поведение для своих конкретных подтипов.

Например, все строковые объекты (через упаковку) в дополнение к `string` примитивам имеют доступ к стандартному поведению с методами определёнными в объекте `String.prototype`.

**Внимание:** В документации к языку,`String.prototype.XYZ` сокращён до `Stryng#XYZ`, это же относится и к другим `prototype`s.

* `String#indexOf(..)`: находит позицию подстроки в строке
* `String#charAt(..)`: определяет характер символа находящегося на указанной позиции
* `String#substr(..)`, `String#substring(..)`, and `String#slice(..)`: возвращает новую строку из фрагмента заданной.
* `String#toUpperCase()` and `String#toLowerCase()`: создаёт новую строку конвертируя заданную в верхний или нижний регистр
* `String#trim()`: создаёт новую строку, удаляя все пробелы.

Примечательно, что методы преобразовывают строки *здесь и сейчас*. Преобразования (как в случае с конвертацией или триммингом) создают новое значение из существующего.

В силу делегирования прототипам (смотри *this  и Прототипы Объектов* этой серии), любое строковое значение имеет доступ к этим методам:

```js
var a = " abc ";

a.indexOf( "c" ); // 3
a.toUpperCase(); // " ABC "
a.trim(); // "abc"
```

Остальные прототипы конструкторов содержат поведение предназначенное для их типов, к примеру `Number#toFixed(..)` (преобразовывает число соответствующее ему с определённым количеством цифр после запятой), или `Array#concat(..)` (объединяет массивы). Все функции также имеют доступ к  `apply(..)`, `call(..)`, и `bind(..)`, потому что они определены с помощью `Function.prototype`.

Однако, некоторые из семейств прототипов не *совсем* являются обычными объектами:

```js
typeof Function.prototype;			// "function"
Function.prototype();				// it's an empty function!

RegExp.prototype.toString();		// "/(?:)/" -- empty regex
"abc".match( RegExp.prototype );	// [""]
```

Это плохая идея, но мы можем даже переопределить эти прототипы семейств (не просто добавить свойства, как вы, наверняка умеете):

```js
Array.isArray( Array.prototype );	// true
Array.prototype.push( 1, 2, 3 );	// 3
Array.prototype;					// [1,2,3]

// don't leave it that way, though, or expect weirdness!
// reset the `Array.prototype` to empty
Array.prototype.length = 0;
```

Также можно заметить, что `Function.prototype` это функция, `RegExp.prototype` это регулярное выражение, и `Array.prototype` это массив. Здорово и познавательно, правда?

#### Прототипы как значения по умолчанию 

`Function.prototype` становится пустой функцией, `Regexp.prototype` становится «пустым» (например не имеющим соответствия) регулярным выражением, а `Array.prototype` становится пустым массивом, что делает их замечательными «значениями по умолчанию» для задания к переменным, если эти переменные не должны сразу иметь значение соответствующего типа.

Например:

```js
function isThisCool(vals,fn,rx) {
	vals = vals || Array.prototype;
	fn = fn || Function.prototype;
	rx = rx || RegExp.prototype;

	return rx.test(
		vals.map( fn ).join( "" )
	);
}

isThisCool();		// true

isThisCool(
	["a","b","c"],
	function(v){ return v.toUpperCase(); },
	/D/
);					// false
```

**Внимание:** Начиная с ES6, у нас больше нет необходимости использовать синтаксический приём конструкции значения по умолчанию `vals = vals || …` (см. главу 4), потому что значения по умолчанию могут быть присвоены параметрам через встроенный синтаксис при определении функции (см. главу 5).

В этом подходе есть небольшой побочный эффект, `prototype`s уже были созданы и встроены, как *разово* созданные. Для контраста, использование самих значений `[]`, `function(){}`, и `/(?:)/` этими «значениями по умолчанию» опять создаст (вероятно, в зависимости от реализации движка) те значения (и вероятно сборщика мусора для них) при *каждом вызове* `isThisCool(..)`. Это  немного расточительно для памяти/процессора.

Также, стоит быть очень осмотрительным и не использовать `Array.prototype` как значение по умолчанию, **которое впоследствии будет изменено**. В примере выше `vals` использовано только для чтения, но если бы мы по месту внесли изменения в `vals`, мы изменили бы сам `Array.prototype`, что привело бы к изъянам описанным для массивов ранее!

**Внимание:** Хоть мы и упоминаем здесь прототипы семейств, и некоторые их полезноти, будь внимательным, если обращаешься к ним, и даже осторожным, когда пытаешься преобразовать их любым способом. Смотри Приложение А «Прототипы Семейств» для более детального обсуждения.

## Обзор

Javascript обеспечивает объекты-обёртки известные как семейства (`String`, `Number`, `Boolean`, и др.) вокруг примитивных значений. Эти объекты обёртки дают значениям доступ к, свойствам предназначенным для подтипов каждого такого объекта (`String#trim()`, `Array#concat(..)` ).

Если есть обычное скалярное значение примитива вроде `”abc”` и мы вызываем его свойство `length` или другой `String.prototype` метод, JS автоматически «упаковывает» значение (оборачивает его в соответствующий объект-обёртку), поэтому обращение к этому свойство/методу может осуществляться.
