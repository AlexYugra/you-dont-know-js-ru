# Вы не знаете JS: This и Прототипы Объектов
# Глава 4: Смешивая объекты "классов"

Продолжая исследование объектов, начатое в предыдущей главе, вполне естественно, что теперь мы обратим внимание на «объектно-ориентированное (OO) программирование», с «классами».  Мы рассмотрим «класс-оринтированность» в качестве шаблона проектирования, прежде чем изучать механику «классов»: «создание экземпляров», «наследование» и «(относительный) полиморфизм».

Мы увидим, что эти понятия на самом деле не очень хорошо соотносятся с механизмами работы с объектами в JS (mixins и т. д.), и многие разработчики JavaScript идут на преодоление подобных вызовов.

** Примечание: ** В этой главе уделяется довольно много внимания (первая половина!) тяжеловесной  теории «объективно-ориентированного программирования». В конце концов мы свяжем эти идеи с реальным JavaScript кодом во второй половине, где мы поговорим о «миксинах (mixins)». Но будет рассмотрено много концепций и псевдокода, чтобы продвинуться вперед, поэтому не теряйтесь - просто потерпите!

## Теория классов

"Классовое наследование" описывает определенный подход к архитектуре и организации кода - способ моделирования реальных проблемных областей в нашем программном обеспечении.

ОО или класс-ориентированное программирование делает акцент на том, что данные в действительности имеют схожее поведение (конечно, разное в зависимости от типа и природы данных!), влияющее на них, поэтому соответствующий дизайн должен упаковать (ака, инкапсулировать) данные и их поведение вместе. В формальной информатике это иногда называют "структурами данных".

Например, некая последовательность символов, представляющая сообой слово или фразу, обычно называется "строка". Данными здесь являются символы. Но вам почти никогда не интересны данные, обычно Вы хотите с этими данными *что-то делать*, поэтому все операции, которые могут  применяться *к* этим данным (вычисление длины, добавление данных, поиск и т. д.) разработаны как методы класса 'String'.

Любая данная строка просто является экземпляром этого класса, что означает, что это аккуратно собранная упаковка как символьных данных, так и функциональности, которую мы можем к ним применить.

Классы также несут в себе способ *классификации* определенной структуры данных. То, как мы это делаем, - это воспринимать любую заданную структуру как о конкретную вариации более общего базового определения.

Давайте рассмотрим этот процесс "классификации" на часто используемом примере: *автомобиль* можно описать как некую частную реализацию более общего "класса" предметов, называемого *транспортные средства*.

В программном обеспечении мы моделируем данную связь с помощью классов, определяя класс `транспортные средства` и класс `автомобиль`.

Определение `транспортные средства` может включать в себя такие понятия, как силовая установка (ДВС и т. д.), способность перевозить людей, и так далее, все это будет неким поведением класса. Все, что мы определяем в "транспортном средстве", - это принципы, являющиеся общими для всех (или большинства) возможных типов транспортных средств ("самолеты, поезда и автомобили").

Возможно, нет смысла снова и снова переопределять в нашей программе базовую сущность "способности перевозить людей" для каждого типа транспортного средства. Вместо этого мы определим данную возможность один раз в "транспортном средстве", а далее, описывая "автомобиль", мы просто укажем, что он "наследует" (или "расширяет") базовое определение от "транспортного средства". Определение "автомобиля", как говорят, уточняет, общее определение "транспортного средства".

В то время как `транспортное средство` и `автомобиль` определяют поведение посредством методов, данными экземпляра будут такие вещи, как уникальный VIN конкретного автомобиля и т. д.

**Таким образом возникают классы, наследование и создание экземпляров.**

Другим ключевым понятием касательно классов является "полиморфизм", который описывает идею о том, что общее поведение, описанное в родительском классе может быть переопределено в дочернем классе, чтобы придать ему больше конкретики. Фактически, относительный полиморфизм позволяет нам ссылаться на базовое поведение из переопределенного.

Теория классов предполагает, что родительский и дочерний классы разделяют название методов для описания определенного поведения, так что потомок переопределеят родительскую реализацию. Как мы увидим позже, подобные вещи в вашем JavaScript коде могут привести к разочарованию и хрупкости кода.

### Шаблон проектирования "Класс"

Возможно, вы никогда не смотрели на классы как на "шаблон проектирования", так как чаще всего обсуждаются популярные "OO шаблоны проектирования", такие как "итератор", "наблюдатель", "фабрика", "синглтон" и т.д. При этом сразу предполагается, что OO классы являются механизмами более низкого уровня, с помощью которых мы реализуем все шаблоны проектирования (более высокого уровня), как будто OO является единственно-верной основой для *всего* (правильного) кода.

В зависимости от вашего уровня формального образования в области программирования, вы, возможно, слышали о "процедурном программировании" как способе описания кода, который состоит только из процедур (ака, функций), вызывающих другие функции, без каких-либо более высокоуровневых абстракций. Возможно, вас учили, что классы были *правильным* способом преобразования процедурного "спагетти-кода" в хорошо оформленный организованный код.

Конечно, если у вас есть опыт в "функциональном программировании" (монады и др.), вы хорошо знаете, что классы являются лишь одним из нескольких распространенных шаблонов проектирования. Но другие, возможно, впервые спросят себя, а действительно ли классы являются фундаментальной основой для написания кода, или они являются необязательной абстракцией.

Некоторые языки (например, Java) не оставляют вам выбора, поэтому это восе не *опционально* - все это класс. Другие языки, такие как C/C++ или PHP, предоставляют вам как процедурные, так и классовые синтаксисы, и больше зависит от выбора разработчика, какой стиль или смесь стилей ему подойдет.

### "Классы" JavaScript

Где JavaScript начинает иметь к этому всему отношение? JS имеет *некоторые* синтаксические элементы, подобные классу (например, `new` и `instanceof`) довольно давно, а в последнее время в ES6 появились некоторые дополнения, такие как ключевое слово `class` (см. приложение A).

Но значит ли это, что в JavaScript действительно *есть* классы? Строго и однозначно: **Нет.**

Поскольку классы являются шаблоном проектирования, вы *можете*, приложив немало усилий (как мы увидим далее в этой главе), реализовать некоторое приближение для большей части классической функциональности класса. JS пытается удовлетворить чрезвычайно распространенное *желание* проектировать с классами, предоставляя, казалось бы, похожий на классы синтаксис.

Хотя у нас и может быть синтаксис, похожий на классы, это больше похоже на то, что механика JavaScript борется против того, чтобы вы использовали шаблон проектирования *class*. Так как под капотом механизмы, которые вы строите, работают совсем по-другому. Синтаксический сахар и (очень широко используемые) JS библиотеки для работы с "классами" проходят долгий путь скрывая эту реальности от вас, но рано или поздно вы столкнетесь с тем, что *классы* которые у вас есть в других языках не похожи на фейковые "классы", которые мы создаем себе в JS.

Все это сводится к тому, что классы не являются обязательным шаблоном при разработке программного обеспечения, и у вас есть выбор, использовать их в JavaScript или нет. Поскольку многие разработчики имеют сильную тягу к класс-ориентированному дизайну программного обеспечения, мы посвятим оставшуюся часть этой главы расмотрению того, чего стоит поддержание иллюзии классов с использованием тех механизмов, что предоставляет JS, и тех проблем, которые мы при этом испытываем.

## Механика Классов

Во многих классовых языках "стандартная библиотека" предоставляет "стековую" структуру данных (push, pop и др.) как класс `Stack`. Этот класс имеет внутренний набор переменных, которые хранят данные, и набор публичных методов, которые дают вашему коду возможность взаимодействовать со (скрытыми) данными (добавление и удаление данных и т. д.).

Но в подобных языках вы на самом деле не работаете непосредственно со `Stack` (если только речь не идет о **Static** члене класса, но это выходит за рамки нашего обсуждения). Класс `Stack` - это просто абстрактное описание того, что должен делать *любой* "стек", но это не *сам* "стек". Вы должны **создать экземпляр** класса `Stack`, прежде чем у вас будет конкретная структура данных *нечто* для работы с ней.

### Строительство

Традиционное понимание терминов «класс» и «экземпляр» пришло из концепции строительства зданий.

К примеру, архитектор моделирует основные характеристики здания: ширину, высоту, количество окон и их расположение, даже материалы для стен и крыши. Сейчас у него нет необходимости беспокоиться ни, *где* это здание будет строиться ни, *сколько* будет построено экземпляров.

Также, архитектор не особо заботится о детализации здания, вроде фурнитуры, обоев, вытяжек и др., только о структуре, в которую они будут монтироваться.

Проекты, созданные архитектором, это только *планы(чертежи)*  здания. Они в действительности не предоставляют здание, в которое мы можем войти и присесть. Для такой задачи нам понадобится строитель. Строитель возьмёт эти чертежи и будет точно следовать им при *строительстве* здания. В буквальном смысле он *скопирует* предначертанные характеристики в реальное здание.

По окончании строительства здание станет фактической конкретизацией проектных чертежей, будем надеяться, совершенной, по сути, *копией*.  И, тогда строитель  сможет взять соседний участок и сделать все по новой, создав ещё одну *копию*.

Между зданием и проектными планами взаимосвязь косвенна.  Мы можем проверить планы, чтобы разобраться, как здание было спроектировано, для любой его части, если непосредственная проверка в самом здании была недостаточной. Но, если нам захочется открыть дверь, нам придётся проследовать в само здание, на планах  мы только  увидим рисунки с линиями, которые *представят* нам,  где дверь должна находиться.

Класс  это чертёж. Чтобы *получить* реальный объект мы можем взаимодействовать с классом, мы должны строить («образовывать») что-то из класса. Конечным результатом такой конструкции будет объект, обычно называемый «экземпляр», откуда мы можем напрямую вызывать методы и предоставлять доступ к любым общим данным, если необходимо. 

Такой объект **является *копией*** всех характеристик, представленных в классе.

Вряд ли мы ожидаем войти в здание и найти в рамке на стене копию плана, используемую для проектирования здания, скорее всего планы находятся в офисе в файле с публичными документами. Также обычно экземпляры не используются, чтобы напрямую манипулировать классами, однако обычно возможно как минимум определить из *какого класса* объёкт приходится.

Рассматривать прямую связь от класса к экземпляру объекта будет полезнее, чем любые непрямые взаимосвязи между объектом и классом из которого он создан. **Класс преобразовывается в форму объекта операцией копирования.**

<img src="fig1.png">

Обратим внимание на стрелки, идущие слева направо и сверху вниз, которые указывают на операции копирования, как концептуально, так и физически.

### Конструктор

Экземпляры класса, созданные специальным методом класса, обычно с таким же именем как у класса называются *конструктор*. Непосредственная задача этого метода инициализировать любую информацию (состояние), которое потребуется экземпляру.

Рассмотрим следующий псевдокод (синтаксис не соблюдён) для классов:

```js
class CoolGuy {
	specialTrick = nothing

	CoolGuy( trick ) {
		specialTrick = trick
	}

	showOff() {
		output( "Here's my trick: ", specialTrick )
	}
}
```

Для *создания* экземпляра `CoolGuy` нам надо вызвать конструктор класса:

```js
Joe = new CoolGuy( "jumping rope" )

Joe.showOff() // Here's my trick: jumping rope
```

Отметим,  что `CoolGuy` имеет конструктор `CoolGuy()` , что является именно тем, что мы вызываем когда говорим `new CoolGuy(..)`.  Взамен мы получаем объект (наш экземпляр класса) из конструктора, и мы имеем возможность вызвать метод `showOff()`, который выводит специальный трюк конкретного `CoolGuy`.

*Очевидно, прыжки со скакалкой делают Joe клёвым парнем.*

Конструктор класса практически везде *соотносится* с классом по такому же имени. Также конструкторы почти во всех случаях должны вызываться с `new`, чтобы дать движку знать, что мы хотим создать новый экземпляр класса. 

## Наследование в классах 
В класс-ориентированных языках мы можем не только определить класс, который создаёт собственный экземпляр, но и определять другие классы, которые **наследуются** из первого. 

Последующий класс часто называется «дочерний класс»(здесь класс-потомок) тогда как предыдущий «родительский класс». Эти термины, очевидно, понимаются как отношение «родитель-потомок», но это понимание не совсем  метко, в чём мы вскоре убедимся.

Когда у биологического родителя есть ребёнок, генетические характеристики родителя копируются в ребёнка. Очевидно, в большинстве биологических систем существует два родителя, которые в равной степени участвуют в смешении генезиса. Но, в нашем случае мы будем предполагать одного родителя.

Как только ребёнок появляется, он отделяется от родителя. На ребёнка очень сильно повлияли наследственные характеристики его родителя, но он(она) уникален и индивидуален. Если ребёнок вырастает рыжеволосым, это не означает, что у отца *тоже* автоматически *порыжеет* лысина

В той же манере,  как только класс-потомок начинает существование,  он от отделяется и обособляется от родительского класса.  Класс-потомок содержит исходную копию поведения от родителя, но впоследствии может переопределять любое из унаследованных поведений, и даже определять своё собственное. 

Важно помнить, мы говорим о родительских и дочерних классах, а не о физических сущностях. В этом и есть небольшая путаница определения «родитель-потомок», потому что, по правде говоря, мы не можем сказать, что родительский класс это родительское ДНК, а класс-потомок, это ДНК ребёнка. Мы должны создать («образовать») персонаж  с каждым из всех наборов ДНК, чтобы иметь перед собой реальный персонаж, с которым можно будет разговаривать.

Предлагаю отдалиться от биологических «родитель-потомок» и посмотреть на наследственность через другую призму: разные типы транспорта. Это самая применимая (избитая) метафора для понимания наследования.

Давайте пересмотрим предыдущее в этой главе обсуждение `Vehicle` и `Car`. 
Рассмотрим следующий псевдокод (синтаксис не соблюдён) для наследуемых классов:

```js
class Vehicle {
	engines = 1

	ignition() {
		output( "Turning on my engine." )
	}

	drive() {
		ignition()
		output( "Steering and moving forward!" )
	}
}

class Car inherits Vehicle {
	wheels = 4

	drive() {
		inherited:drive()
		output( "Rolling on all ", wheels, " wheels!" )
	}
}

class SpeedBoat inherits Vehicle {
	engines = 2

	ignition() {
		output( "Turning on my ", engines, " engines." )
	}

	pilot() {
		inherited:drive()
		output( "Speeding through the water with ease!" )
	}
}
```

**Примечание:** Для краткости и ясности конструкторы для этих классов d примере пропущены.

Мы определяем класс `Vehicle`, определяя в нём двигатель,  способ включения зажигания, и способ передвижения. Но, мы не производим даже какой бы то ни было  прототип "транспорта", сейчас это абсолютно абстрактное понятие.

Что ж, затем мы определяем  два конкретных випа транспорта:  `Car` и `SpeedBoat`. Оба они наследуют основные характеристики `Vehicle`, но впоследствии они специализируют эти характеристики применительно к своему типу. У `Car` есть 4 колеса, и у `SpeedBoat` два двигателя, что требует дополнительного внимания при включении зажигания в нём обоих двигателей. 

### Полиморфизм

`Car` определяет собственный метод `drive()`, который перезаписывает метод с тем же названием в `Vehicle`. Но, затем в `Car`  метод `drive()` вызывает `inherited:drive()`, который указывает, что `Car` может обращаться к оригинальному не перезаписанному методу `drive()`, который он унаследовал. Метод `pilot()` в `SpeedBoat` также обращается к своей унаследованной копии  `drive()`. 

Такая техника называется «полиморфизм» либо «виртуальный полиморфизм». В более узком для нас понимании мы будем называть её «относительный полиморфизм». 

Полиморфизм  это более  распространённая тема, чем  нами будет рассматриваться, но применённая нами семантика «относительный» относится к одному специфическому аспекту:  идее того, что любой метод может обратиться к другому методу (с таким же или другим именем) в вышестоящей иерархии уровней наследования.  Мы говорим «относительный»,  потому как не определяем с абсолютной точностью, к какому уровню наследования («классу») мы хотим получить доступ, но скорее относительно обращаемся, говоря примерно «на один уровень вверх».

Во многих языках в понятии `inherited:` этого примера  используется ключевое слово `super` , которое опирается на идею того что `super` класс является родителем/предком данного класса. 

Другой стороной полиморфизма является то, что имя метода на разных уровнях цепочки наследования может иметь различные определения, и эти определения автоматически назначаются при принятии решения какой метод будет вызываться.

Мы видим два случая такого поведения в нашем предыдущем примере:  `drive()` определяется в обоих `Vehicle` и `Car`, и `ignition()` определяется в обоих `Vehicle` и `SpeedBoat`. 

**Примечание:** Другой аспект применения `super` в объектно-ориентированных языках это предоставить непосредственную возможность  конструктору класса-потомка обратиться к конструктору его родительского класса. Это в основном так, потому что в настоящих классах конструктор относится к классу. Однако в JS всё наоборот, фактически более подойдёт думать, что «класс» относится к конструктору  (вид отношений `Foo.prototype…`).  Так как в JS отношения между «детьми» и «родителями»  существую только между двумя  `.prototype`  объектов соответствующих конструкторов, сами конструкторы не связаны напрямую и не существует простого способа относительно обратиться одним к другому. (смотри Appendix A для ES6 `class`, который «решает» это с `super`).

Интересный смысл полиморфизма можно тонко наблюдать в  `ignition()`. Внутри `pilot()` относительно-полиморфная ссылка осуществляется к (наследуемой) версии `drive()` из `Vehicle`. Но метод `ignition()` обращается  к вышеопределённому `drive()` по имени, (без использования относительной ссылки).

Какую версию `ignition()` станет использовать движок языка, из `Vehicle` или из `SpeedBoat`?  **Движок станет использовать** `SpeedBoat` **версию** `ignition()`. Если бы вы *создали* экземпляр класса `Vehicle` непосредственно и вызвали его собственный `drive()`, движок языка взамен использовал бы определение метода `ignition()` из `Vehicle`.

Пойдём другой дорогой, определение метода `ignition()` *полиморфируется* (изменяется) в зависимости от того на какой класс (уровень наследования) мы обращаемся в экземпляре.

Это может показаться чрезмерно глубокими академическими деталями. Но, понимание этих деталей необходимо,  чтобы правильно различать похожие (но  обособленные) поведения механизма `[[Prototype]]` в Javascript.

Когда классы наследуются, это возможность **для самих классов** (а, не созданных экземпляров объектов этих классов!) *относительно* обращаться к классам, от которых они наследуются, и это относительное обращений обычно называется `super`.

Вспомним предыдущую фигуру:

<img src="fig1.png">

Отметим, как для конкретных экземпляров (`a1`, `a2`, `b1` и `b2`)так и для наследования (`Bar`), стрелки указывают на операции копирования.

Концептуально это выглядит так, что дочерний класс  (`Bar`) может получить доступ к поведению своего родительского класса `Foo`,  используя относительно-полиморфную ссылку (вроде `super`). Однако класс-потомок просто получает копию наследуемого поведения от своего родительского класса. Если ребёнок перезаписывает наследуемый метод, обе как оригинальная, так и перезаписанная версия этого метода в действительности поддерживаются, так что обе они остаются доступны.

Пусть вас не путает мысль, что дочерний класс ссылается на свой родительский класс. На самом деле класс-потомок получает копию того что ему необходимо из родительского класса. **Наследование классов подразумевает копирование**.

### Множественное наследование

Давайте вспомним наш предыдущий разговор о ДНК детей и родителей? Мы говорили, что это определение слегка расплывчато, потому что биологически потомки нуждаются в наличии двух родителей. Если бы класс наследовался от двух разных классов, это бы более подошло  к определению «родитель-потомок».

Некоторые объектно-ориентированные языки разрешают нам выделить более одного «родителя» для «наследования».  Множественное наследование означает, что определение каждого родительского класса копируется в класс-потомок. 

На первый взгляд, это кажется мощным расширением  в объектно-ориентированных языках, возможность у нас совмещать функциональность. Однако возникает несколько неудобных вопросов. Если оба родительских класса предоставляют метод с именем `drive()`, какую версию `drive()` должен использовать потомок? Ты станешь постоянно вручную, тем нарушая грацию полиморфного наследования,  уточнять какой из родительских `drive()` ты имел ввиду? 

Вот другая вариация, называемая “Диамантовая Проблема», которая указывает на сценарий, где класс-потомок “D” наследует от двух родительских классов (“B”, и “C”) и каждый из этих двух наследует от общего родителя “A”. Если “A” определяет метод `drive()`, а оба класса “B”, и “C” перезаписывают (полиморфят) этот метод, когда “`D`” обращается к методу `drive()`, какую его версию он должен использовать (`B:drive` или `C:drive`)?

<img src="fig2.png">

Подобные сложности заводят даже дальше, чем кажется на первый взгляд. Мы адресуем к ним только для того чтобы обозначить противоположность работы механизма Javascript.

Javascript  проще.  В нём нет встроенного механизма «множественного наследования». Многие расценивают это как правильный подход, потому что сложность потребляет больше чем компенсация от «уменьшенной функциональности». Но, разработчики не останавливаются в попытках подделать это разными способами, как мы увидим далее.

## Миксины

Механизм объектов в Javascript не копирует поведение *автоматически*, кода мы «наследуем» или «производим объекты». По сути в Javascript нет классов для производства, только объекты. Также объекты не копируются в другие объекты, но *связываются вместе* (см. гл.5).

Раз уж рассмотренное поведение классов в других языках подразумевает копирование, давайте изучим как разработчики JS **подделывают** *упущенное* поведение копирования классов в Javascript: миксины. Мы рассмотрим  два типа миксинов **явные** и **неявные**.  

### Явные Миксины

Давайте опять пересмотрим  наш предыдущий пример `Vehicle` и `Car`. Вследствие того, что Javascript автоматически не копирует поведение из  `Vehicle` в `Car`, мы взамен можем создать утилиту, копирующую «вручную». Такая утилита во многих библиотеках/фреймфорках часто называется `extend(..)`, но для наглядности здесь мы назовём её `mixin(..)`.

```js
// vastly simplified `mixin(..)` example:
function mixin( sourceObj, targetObj ) {
	for (var key in sourceObj) {
		// only copy if not already present
		if (!(key in targetObj)) {
			targetObj[key] = sourceObj[key];
		}
	}

	return targetObj;
}

var Vehicle = {
	engines: 1,

	ignition: function() {
		console.log( "Turning on my engine." );
	},

	drive: function() {
		this.ignition();
		console.log( "Steering and moving forward!" );
	}
};

var Car = mixin( Vehicle, {
	wheels: 4,

	drive: function() {
		Vehicle.drive.call( this );
		console.log( "Rolling on all " + this.wheels + " wheels!" );
	}
} );
```

**Примечание:** Важно подчеркнуть, что мы больше не работаем с классами, потому как в Javascript нет классов. Vehicle и Car это просто объекты, из которых и в которые мы копируем соответственно.  

`Car` теперь имеет копию свойств и функций  `Vehicle`. Технически функции на самом деле не дублируются, скорее копируются *ссылки* на функции. Итак `Car` теперь имеет войство с названием `ignition()`, которое есть копия обращения к функции `ignition()`, и свойство `engines`, со скопированным значением “`1`”из `Vehicle`. 

`Car` уже имеет свойство(функцию) `drive()`, поэтому ссылка на это свойство не была перезаписана (обратите внимание на оператора `if` в `mixin()` в примере).

#### «Полиморфизм» Revisited

Рассмотрим формулировку: `Vehicle.drive.call(this)`. Это то, что я называю «явный псевдо-полиморфизм». Как помните, в нашем предыдущем псевдокоде эта строка была `inherited: drive()`, где мы обозвали её «относительный полиморфизм». 

До ES6 (см. Appendix A) в Javascript не имелось способности к относительному полиморфизму. **Из-за того что оба `Car` и `Vehicle` имели функцию с одинаковым названием `drive()`**, чтобы отличить, вызывается первая или вторая, мы должны были создать *абсолютную* (не относительную) ссылку.
Мы явно назвали объект `Vehicle` по имени и вызвали в нём функцию `drive()`.

Но, если мы скажем `Vehicle.drive ()`, то `this` привязанный к вызову для этой функции выведет объект `Vehicle`,  а не  `Car` (см. главу 2), и это не то чего мы хотим. Поэтому мы используем  `.call(this)`
(гл. 2), дабы удостовериться, что `drive()` выполнится в контексте объекта `Car`. 

**Примечание:** Если бы идентификатор функции `Car.drive()` не перекрывался («затенялся» см. гл 5) `Vehicle.drive()` мы бы не стали упражняться в «методе полиморфизма». Так, обращение к `Vehicle.drive()` скопировалось бы вызовом `mixin()` и мы получили бы доступ через `this.drive()`.  Перекрытие выбранным идентификатором **затеняется**, поэтому нам приходится применять сложный подход  *явного псевдо-полиморфизма*.

В класс ориентированных языках имеющих относительный полиморфизм связь между `Car` и `Vehicle` устанавливается единоразово в начале определения класса, что образует только одно место где можно управлять этой взаимосвязью. 

Но, из-за особенностей Javascript, явный псевдо-полиморфизм(особенности затенения!)  создаёт хрупкую ручную/явную привязку **в каждой простой функции где нам нужна такая (псевдо-)полиморфная ссылка**. Это может существенно повысить обслуживание кода. Более того, пока явный псевдо-полиморфизм может эмулировать поведение «множественного наследования» сложность и "ломкость" кода только увеличивается.

Результатом такого подхода обычно становится более сложный, неудобочитаемый и тяжело обслуживаемый код. **Явного полиморфизма следует избегать по возможности**, потому что, в большинстве случаев расходы превышают доходы.

#### Копии Миксинов

Вернёмся к предыдущей утилите `mixin(..)`: 

```js
// vastly simplified `mixin()` example:
function mixin( sourceObj, targetObj ) {
	for (var key in sourceObj) {
		// only copy if not already present
		if (!(key in targetObj)) {
			targetObj[key] = sourceObj[key];
		}
	}

	return targetObj;
}
```

Теперь давайте посмотрим как работает `mixin(..)`. Он итерирует свойства `SourceObj` (`Vehicle` в нашем случае), и если свойство с таким именем отсутствует в `TargetObj` (`Car` в нашем случае), он создаёт копию. Так как мы создаём копию после инициализации объекта, мы действуем аккуратно, чтобы не скопировать свойство поверх собственного. 

Если мы сначала копируем в `Car` до определения собственного содержимого  `Car` мы можем пропустить эту проверку в `TargetObj`, но такой подход неуклюж и менее эффективен, и так им образом менее предпочтителен

```js
// alternate mixin, less "safe" to overwrites
function mixin( sourceObj, targetObj ) {
	for (var key in sourceObj) {
		targetObj[key] = sourceObj[key];
	}

	return targetObj;
}

var Vehicle = {
	// ...
};

// first, create an empty object with
// Vehicle's stuff copied in
var Car = mixin( Vehicle, { } );

// now copy the intended contents into Car
mixin( {
	wheels: 4,

	drive: function() {
		// ...
	}
}, Car );
```

При любом подходе мы явно копировали неперекрываемое содержимое из Vehicle в Car. Название “mixin” можно рассматривать как альтернативное объяснение задачи: к `Car` **подмешивается** содержимое `Vehicle`, словно мы добавляем шоколадную стружку в наше любимое тесто для выпечки.

Как результат операции копирования `Car`  станет дейтвовать в каком-то смысле отдельно от `Vehicle`, Если мы добавим свойство в `Car`, оно не затронет `Vehicle` и наоборот. 

**Примечание:** Здесь мы j, обходим стороной некоторые нюансы. Всё ещё остаются  незначительные вариации, когда один объект может «повлиять» на другой даже после копирования , к примеру если оба они раздают ссылку на общедоступный объект (такой как массив).

Так как два объекта тоже раздают ссылки на их основные функции, это означает, что **даже ручное копирование функций (вроде миксинов) из одного объекта в другой в действительности не эмулирует реальное дублирование от класса к экземпляру как это происходит в объектно-ориетированных языках**.

Функции в Javascript в реальности не дублируются (стандартным способом) и в итоге мы имеем дело с **дублированием ссылки** на один общедоступный объект функции (см. гл 3 Функции это объекты). Если мы изменим один из публичных **объектов/функций** (типа `ignition()`) например добавив свойства поверх существующих,  оба, как `Vehicle` так и `Car` оказажутся затронутыми посредством общей ссылки. 

Явные Миксины - тонкий механизм в Javascript. Но, они кажутся более мощными, чем есть на самом деле. *По сути* от копирования свойства из одного объекта в другой **не выгоднее чем определение свойств дважды в каждом объекте**. И, это особенно верно для отмеченного сейчас нюанса в отношениях функций-объектов.

Если мы явно смешиваем два или более объектов в приготовленный объект нам удастся **частично эмулировать** поведение «множественного наследования», но у нас нет прямого механизма обработки ошибок, если метод с таким же именем копируется более чем из одного источника. Некоторые разработчики подходят к решению с техникой «позднего связывания» и другими экзотическими наработками, но по существу эти «трюки» *обычно* обращаются большими усилиями (и меньшей производительностью!) чем премуществом.

Задумывайтесь об использовании явных миксинов только там где это несомненно поможет сделать код более читаемым, и избегайте шаблонов, если вы найдёте что они делают код более трудно отслеживаемым или найдёте что они делают зависимости между объектами громоздкими и бесполезными. 

**Если изящное использование миксинов станет труднее, чем получалось ранее**, вы должны, вероятно, перестать пользоваться ими. Факт того, что Вам придётся пользоваться сложными библиотеками/утилитами чтобы оперировать такими деталями, должен послужить сигналом, что выбран сложный вариант, и, пожалуй, обходимый. В главе 6 мы попробуем  очистить более простую дорожку для достижения желаемого без  ненужной суеты.

#### Паразитное наследование

Вариация шаблона явных Миксинов, которые в  тоже время, с одной стороны явные, а с другой неявные называется «паразитное наследование» , в основном пропагандируемая Дугласом Крокфордом (Douglas Crockford).

Как это работает:

```js
// "Traditional JS Class" `Vehicle`
function Vehicle() {
	this.engines = 1;
}
Vehicle.prototype.ignition = function() {
	console.log( "Turning on my engine." );
};
Vehicle.prototype.drive = function() {
	this.ignition();
	console.log( "Steering and moving forward!" );
};

// "Parasitic Class" `Car`
function Car() {
	// first, `car` is a `Vehicle`
	var car = new Vehicle();

	// now, let's modify our `car` to specialize it
	car.wheels = 4;

	// save a privileged reference to `Vehicle::drive()`
	var vehDrive = car.drive;

	// override `Vehicle::drive()`
	car.drive = function() {
		vehDrive.call( this );
		console.log( "Rolling on all " + this.wheels + " wheels!" );
	};

	return car;
}

var myCar = new Car();

myCar.drive();
// Turning on my engine.
// Steering and moving forward!
// Rolling on all 4 wheels!
```

Как видно, мы изначально делаем копию определения родительского класса (объекта) `Vehicle`, затем смешиваем определение класса-потомка (объект) (сохраняя привилегию ссылок родительского класса при необходимости), и возвращаем такой смешанный объект `car` как наш экземпляр класса-потомка.

**Примечание:** Когда мы вызываем `new Car()`, создаётся новый объект связанный с `this` объекта `Car` (см. гл. 2). Но, так как мы не используем этот объект, а вместо него возвращаем наш собственный `car`. Изначально созданный объект отбрасывается. Тогда `Car()` может вызываться без ключевого слова new, и функциональность будет идентичной, но без ненужного создания объекта/удаления мусора.

### Неявные миксины 

Неявные миксины очень близки по отношению к *явному псевдо-полиморфизму*  как объяснялось ранее. Поэтому с ними имеют место те  же оговорки и предупреждения.

Посмотрите на этот код:

```js
var Something = {
	cool: function() {
		this.greeting = "Hello World";
		this.count = this.count ? this.count + 1 : 1;
	}
};

Something.cool();
Something.greeting; // "Hello World"
Something.count; // 1

var Another = {
	cool: function() {
		// implicit mixin of `Something` to `Another`
		Something.cool.call( this );
	}
};

Another.cool();
Another.greeting; // "Hello World"
Another.count; // 1 (not shared state with `Something`)
```

С `Something.cool.call(this)`, которое может присутствовать как в вызове «конструктора» (в большинстве случаев) так и в вызове метода (как в примере), мы, по существу, «одалживаем» функцию `Something.cool()` и вызываем её в контексте `Another` (посредством привязки `this`; см. гл 2) вместо `Something`. Конечный результат таков, что задачи, присвоенные `Something.cool()` используются объектом `Another`, а не объектом `Something`.

Поэтому говорится, что мы «подмешиваем»(миксируем) поведение Something c (или в) Another.

В то время как такой сорт техники выглядит полезной продвинутостью функциональной перепривязки this, такой вызов `Something.cool.call(this)` ненадёжен и не может переделаться в относительную (и таким образом более гибкую) ссылку, к чему требуется **относиться с осторожностью**. В общих случаях **таких конструкций следует избегать**, чтобы содержать код чистым и пригодным к обслуживанию.

## Обзор (TL;DR) 

Классы – дизайн проектирования. Множество языков обеспечивают синтаксис  включающий в себя классо-ориентированное программное обеспечение. JS имеет похожий синтаксис, но ведёт себя совершенно по другому с тем, как используются классы в других языках. 

**Классы подразумевают копирование.**

Когда традиционные классы создают экземпляры, экземпляр получает копию поведения класса. Также при наследовании копия поведения копируется от родителя к потомку.

Полиморфизм (наличие одноимённых функций с неодинаковым содержанием на разных уровнях наследования)может выглядеть как намёк на обратную относительную ссылку от потомка к родителю, но всё ещё остаётся результатом копии поведения.

Javascript **не создаёт копий автоматически** (как подразумевается классами) между объектами.

Шаблоны миксинов (как явные так и неявные) часто используется для *сортировки* эмуляции поведения копии класса, но обычно это приводит к уродливому и ломаному синтаксису вроде явного псевдо-полиморфизма (`OtherObj.method.call(this, …)`), что в общих случаях делает код  нечитабельным и трудным в обслуживании.

О явных миксинах также нельзя с точностью утверждать, что они являются копией класса, так как объекты (и функции!) только имеют общедоступные дублированные ссылки, но (ни объекты, ни функции) не дублируют сами себя. Невнимание к этому нюансу порождает множество ошибок.

В общих случаях подделки классов в JS, вместо решения реальной проблемы, закладывают «мины замедленного действия» в будущем коде.
